<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Lazy API of Polars"><title>polars_lazy - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-2eb46af5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="polars_lazy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.94.0-nightly (31cd367b9 2026-01-08)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7bab91a1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate polars_lazy</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../polars_lazy/index.html">polars_<wbr>lazy</a><span class="version">0.53.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#lazy-dsl" title="Lazy DSL">Lazy DSL</a><ul><li><a href="#examples" title="Examples">Examples</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>polars_<wbr>lazy</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/polars_lazy/lib.rs.html#1-214">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Lazy API of Polars</p>
<p>The lazy API of Polars supports a subset of the eager API. Apart from the distributed compute,
it is very similar to <a href="https://spark.apache.org/">Apache Spark</a>. You write queries in a
domain specific language. These queries translate to a logical plan, which represent your query steps.
Before execution this logical plan is optimized and may change the order of operations if this will increase performance.
Or implicit type casts may be added such that execution of the query won’t lead to a type error (if it can be resolved).</p>
<h2 id="lazy-dsl"><a class="doc-anchor" href="#lazy-dsl">§</a>Lazy DSL</h2>
<p>The lazy API of polars replaces the eager <a href="../polars_core/frame/dataframe/struct.DataFrame.html" title="struct polars_core::frame::dataframe::DataFrame"><code>DataFrame</code></a> with the <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a>, through which
the lazy API is exposed.
The <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a> represents a logical execution plan: a sequence of operations to perform on a concrete data source.
These operations are not executed until we call <a href="frame/struct.LazyFrame.html#method.collect" title="method polars_lazy::frame::LazyFrame::collect"><code>collect</code></a>.
This allows polars to optimize/reorder the query which may lead to faster queries or fewer type errors.</p>
<p>In general, a <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a> requires a concrete data source — a <a href="../polars_core/frame/dataframe/struct.DataFrame.html" title="struct polars_core::frame::dataframe::DataFrame"><code>DataFrame</code></a>, a file on disk, etc. — which polars-lazy
then applies the user-specified sequence of operations to.
To obtain a <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a> from an existing <a href="../polars_core/frame/dataframe/struct.DataFrame.html" title="struct polars_core::frame::dataframe::DataFrame"><code>DataFrame</code></a>, we call the <a href="frame/trait.IntoLazy.html#tymethod.lazy" title="method polars_lazy::frame::IntoLazy::lazy"><code>lazy</code></a> method on
the <a href="../polars_core/frame/dataframe/struct.DataFrame.html" title="struct polars_core::frame::dataframe::DataFrame"><code>DataFrame</code></a>.
A <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a> can also be obtained through the lazy versions of file readers, such as <a href="frame/struct.LazyCsvReader.html" title="struct polars_lazy::frame::LazyCsvReader"><code>LazyCsvReader</code></a>.</p>
<p>The other major component of the polars lazy API is <a href="dsl/enum.Expr.html" title="enum polars_lazy::dsl::Expr"><code>Expr</code></a>, which represents an operation to be
performed on a <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a>, such as mapping over a column, filtering, or groupby-aggregation.
<a href="dsl/enum.Expr.html" title="enum polars_lazy::dsl::Expr"><code>Expr</code></a> and the functions that produce them can be found in the <a href="dsl/index.html" title="mod polars_lazy::dsl">dsl module</a>.</p>
<p>Most operations on a <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a> consume the <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a> and return a new <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a> with the updated plan.
If you need to use the same <a href="frame/struct.LazyFrame.html" title="struct polars_lazy::frame::LazyFrame"><code>LazyFrame</code></a> multiple times, you should <a href="frame/struct.LazyFrame.html#method.clone" title="method polars_lazy::frame::LazyFrame::clone"><code>clone</code></a> it, and optionally
<a href="frame/struct.LazyFrame.html#method.cache" title="method polars_lazy::frame::LazyFrame::cache"><code>cache</code></a> it beforehand.</p>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3><h5 id="adding-a-new-column-to-a-lazy-dataframe"><a class="doc-anchor" href="#adding-a-new-column-to-a-lazy-dataframe">§</a>Adding a new column to a lazy DataFrame</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df!</span> {
     <span class="string">"column_a" </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">"column_b" </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     <span class="comment">// Note the reverse here!!
     </span>.reverse()
     .with_column(
         <span class="comment">// always rename a new column
         </span>(col(<span class="string">"column_a"</span>) * lit(<span class="number">10</span>)).alias(<span class="string">"new_column"</span>)
     )
     .collect()
     .unwrap();

 <span class="macro">assert!</span>(new.column(<span class="string">"new_column"</span>)
     .unwrap()
     .equals(
         <span class="kw-2">&amp;</span>Column::new(<span class="string">"new_column"</span>.into(), <span class="kw-2">&amp;</span>[<span class="number">50</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>])
     )
 );</code></pre></div><h5 id="modifying-a-column-based-on-some-predicate"><a class="doc-anchor" href="#modifying-a-column-based-on-some-predicate">§</a>Modifying a column based on some predicate</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df!</span> {
     <span class="string">"column_a" </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">"column_b" </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     .with_column(
         <span class="comment">// value = 100 if x &lt; 3 else x
         </span>when(
             col(<span class="string">"column_a"</span>).lt(lit(<span class="number">3</span>))
         ).then(
             lit(<span class="number">100</span>)
         ).otherwise(
             col(<span class="string">"column_a"</span>)
         ).alias(<span class="string">"new_column"</span>)
     )
     .collect()
     .unwrap();

 <span class="macro">assert!</span>(new.column(<span class="string">"new_column"</span>)
     .unwrap()
     .equals(
         <span class="kw-2">&amp;</span>Column::new(<span class="string">"new_column"</span>.into(), <span class="kw-2">&amp;</span>[<span class="number">100</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])
     )
 );</code></pre></div><h5 id="groupby--aggregations"><a class="doc-anchor" href="#groupby--aggregations">§</a>Groupby + Aggregations</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_core::df;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">fn </span>example() -&gt; PolarsResult&lt;DataFrame&gt; {
     <span class="kw">let </span>df = <span class="macro">df!</span>(
         <span class="string">"date" </span>=&gt; [<span class="string">"2020-08-21"</span>, <span class="string">"2020-08-21"</span>, <span class="string">"2020-08-22"</span>, <span class="string">"2020-08-23"</span>, <span class="string">"2020-08-22"</span>],
         <span class="string">"temp" </span>=&gt; [<span class="number">20</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>],
         <span class="string">"rain" </span>=&gt; [<span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.01</span>]
     )<span class="question-mark">?</span>;

     df.lazy()
     .group_by([col(<span class="string">"date"</span>)])
     .agg([
         col(<span class="string">"rain"</span>).min().alias(<span class="string">"min_rain"</span>),
         col(<span class="string">"rain"</span>).sum().alias(<span class="string">"sum_rain"</span>),
         col(<span class="string">"rain"</span>).quantile(lit(<span class="number">0.5</span>), QuantileMethod::Nearest).alias(<span class="string">"median_rain"</span>),
     ])
     .sort([<span class="string">"date"</span>], Default::default())
     .collect()
 }</code></pre></div><h5 id="calling-any-function"><a class="doc-anchor" href="#calling-any-function">§</a>Calling any function</h5>
<p>Below we lazily call a custom closure of type <code>Series =&gt; Result&lt;Series&gt;</code>. Because the closure
changes the type/variant of the Series we also define the return type. This is important because
due to the laziness the types should be known beforehand. Note that by applying these custom
functions you have access to the whole <strong>eager API</strong> of the Series/ChunkedArrays.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> <span class="attr">#[macro_use] </span><span class="kw">extern crate </span>polars_core;
 <span class="kw">use </span>polars_core::prelude::<span class="kw-2">*</span>;
 <span class="kw">use </span>polars_lazy::prelude::<span class="kw-2">*</span>;

 <span class="kw">let </span>df = <span class="macro">df!</span> {
     <span class="string">"column_a" </span>=&gt; <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],
     <span class="string">"column_b" </span>=&gt; <span class="kw-2">&amp;</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]
 }.unwrap();

 <span class="kw">let </span>new = df.lazy()
     .with_column(
         col(<span class="string">"column_a"</span>)
         <span class="comment">// apply a custom closure Series =&gt; Result&lt;Series&gt;
         </span>.map(
             |_s| <span class="prelude-val">Ok</span>(Column::new(<span class="string">""</span>.into(), <span class="kw-2">&amp;</span>[<span class="number">6.0f32</span>, <span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>])),
             <span class="comment">// return type of the closure
             </span>|<span class="kw">_</span>, f| <span class="prelude-val">Ok</span>(Field::new(f.name().clone(), DataType::Float64))
         ).alias(<span class="string">"new_column"</span>),
     )
     .collect()
     .unwrap();</code></pre></div><h5 id="joins-filters-and-projections"><a class="doc-anchor" href="#joins-filters-and-projections">§</a>Joins, filters and projections</h5>
<p>In the query below we do a lazy join and afterwards we filter rows based on the predicate <code>a &lt; 2</code>.
And last we select the columns <code>"b"</code> and <code>"c_first"</code>. In an eager API this query would be very
suboptimal because we join on DataFrames with more columns and rows than needed. In this case
the query optimizer will do the selection of the columns (projection) and the filtering of the
rows (selection) before the join, thereby reducing the amount of work done by the query.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn </span>example(df_a: DataFrame, df_b: DataFrame) -&gt; LazyFrame {
    df_a.lazy()
    .left_join(df_b.lazy(), col(<span class="string">"b_left"</span>), col(<span class="string">"b_right"</span>))
    .filter(
        col(<span class="string">"a"</span>).lt(lit(<span class="number">2</span>))
    )
    .group_by([col(<span class="string">"b"</span>)])
    .agg(
        <span class="macro">vec!</span>[col(<span class="string">"b"</span>).first().alias(<span class="string">"first_b"</span>), col(<span class="string">"c"</span>).first().alias(<span class="string">"first_c"</span>)]
     )
    .select(<span class="kw-2">&amp;</span>[col(<span class="string">"b"</span>), col(<span class="string">"c_first"</span>)])
}</code></pre></div>
<p>If we want to do an aggregation on all columns we can use the wildcard operator <code>*</code> to achieve this.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="kw">fn </span>aggregate_all_columns(df_a: DataFrame) -&gt; LazyFrame {
    df_a.lazy()
    .group_by([col(<span class="string">"b"</span>)])
    .agg(
        <span class="macro">vec!</span>[col(<span class="string">"*"</span>).first()]
     )
}</code></pre></div></div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="dsl/index.html" title="mod polars_lazy::dsl">dsl</a></dt><dd>Domain specific language for the Lazy API.</dd><dt><a class="mod" href="frame/index.html" title="mod polars_lazy::frame">frame</a></dt><dd>Lazy variant of a <a href="../polars_core/frame/dataframe/struct.DataFrame.html" title="struct polars_core::frame::dataframe::DataFrame">DataFrame</a>.</dd><dt><a class="mod" href="prelude/index.html" title="mod polars_lazy::prelude">prelude</a></dt></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.fallible.html" title="macro polars_lazy::fallible">fallible</a></dt><dd>Helper to delay a failing method until the query plan is collected</dd></dl><script type="text/json" id="notable-traits-data">{"<Arc<S> as Service<Request>>::Future":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/fs/struct.File.html\" title=\"struct std::fs::File\">File</a>&gt;</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/fs/struct.File.html\" title=\"struct std::fs::File\">File</a>&gt;</div><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/sync/struct.Arc.html\" title=\"struct alloc::sync::Arc\">Arc</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/fs/struct.File.html\" title=\"struct std::fs::File\">File</a>&gt;</div>"}</script></section></div></main></body></html>