searchState.loadedDescShard("polars_core", 0, "Enable the global string cache as long as the object is …\nAsserts that two expressions of type <code>DataFrame</code> are equal …\nThe typed heart of every Series column.\nData types supported by Polars.\nDisable and clear the global string cache.\nApply a macro on the Downcasted ChunkedArray’s of …\nApply a macro on the Downcasted ChunkedArray’s of …\nEnable the global string cache.\nDataFrame module.\nFunctions\nApply a macro on the Downcasted ChunkedArray’s\nApply a macro on the Series\nApply a macro on the Series\nEverything you need to get started with Polars.\nType agnostic columnar data structure.\nTesting utilities.\nCheck whether the global string cache is enabled.\nChunkedArray\nReturns whether all values in the array are <code>true</code>.\nReturns whether all values in the column are <code>true</code>.\nThis is an iterator over a <code>ListChunked</code> that saves …\nSee <code>amortized_iter</code>.\nReturns whether any of the values in the column are <code>true</code>.\nReturns whether any of the values in the column are <code>true</code>.\nAppend in place. This is done by adding the chunks of <code>other</code>…\nApply a closure <code>F</code> elementwise.\nApply a closure <code>F</code> elementwise.\nCast a numeric array to another numeric data type and …\nApplies a function only to the non-null elements, …\nUtility that reuses an string buffer to amortize …\nIgnore the list indices and apply <code>func</code> to the inner type …\nPanics\nImplementations of arithmetic operations on ChunkedArray’…\nImplementations of the ChunkCast Trait.\nCast a numeric array to another numeric data type and …\nReturns an iterator over the lengths of the chunks of the …\nA reference to the chunks\nA mutable reference to the chunks\nMethods for collecting into a ChunkedArray.\nReturns the values of the array as a contiguous slice.\nCopies <code>Metadata</code> properties specified by <code>props</code> from <code>other</code> …\nCopies <code>Metadata</code> properties specified by <code>props</code>  from <code>other</code> …\nGet slices of the underlying arrow data. NOTE: null values …\nGet data type of <code>ChunkedArray</code>.\nGet a reference to the used <code>Metadata</code>\nExtend the memory backed by this array with the values …\nGet the index of the first non null value in this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>ChunkedArray</code> from existing chunks.\nCreate a new <code>ChunkedArray</code> from existing chunks.\nCreate a new ChunkedArray from an iterator.\nImplementations of upstream traits for <code>ChunkedArray&lt;T&gt;</code>\nCreate a new ChunkedArray by taking ownership of the Vec. …\nCreate a new ChunkedArray from a Vec and a validity mask.\nGet a single value from this <code>ChunkedArray</code>. If the return …\nGet the inner values as <code>Series</code>, ignoring the list offsets.\nGet a hold to an object that can be formatted or …\nGet a hold to an object that can be formatted or …\nGet a single value from this <code>ChunkedArray</code>. If the return …\nReturn if any the chunks in this <code>ChunkedArray</code> have a …\nGet the head of the <code>ChunkedArray</code>\nGet the inner data type of the list.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if ChunkedArray is empty.\nGet a mask of the valid values.\nGet a mask of the null values.\nReturns true if contains a single chunk and has no null …\nReturns an iterator over the offsets of this chunked array.\nGet the buffer of bits representing null values\nGet the index of the last non null value in this …\nGet the length of the ChunkedArray\nApply lhs / self\nApply lhs % self\nApply lhs - self\nTake a view of top n elements\nGet a reference to the <code>ChunkedArray</code>’s <code>Metadata</code>\nGet a reference to <code>Arc</code> that contains the <code>ChunkedArray</code>’s …\nGet a mutable reference to the <code>Arc</code> that contains the …\nGet a <code>Arc</code> that contains the <code>ChunkedArray</code>’s <code>Metadata</code>\nCreate a temporary <code>ChunkedArray</code> from a slice.\nCreate a temporary <code>ChunkedArray</code> from a slice.\nName of the <code>ChunkedArray</code>.\nSpecialization that prevents an allocation prefer this …\nCreate a new <code>ChunkedArray</code> and compute its <code>length</code> and …\nCreate a new <code>ChunkedArray</code> and explicitly set its <code>length</code> …\nConvert missing values to <code>NaN</code> values.\nReturn the number of null values in the ChunkedArray.\nTraits for miscellaneous operations on ChunkedArray\nRemove empty chunks.\nCreate <code>ChunkedArray</code> with samples from a Bernoulli …\nCreate <code>ChunkedArray</code> with samples from a Normal …\nCreate <code>ChunkedArray</code> with samples from a Standard Normal …\nCreate <code>ChunkedArray</code> with samples from a Uniform …\nGet a reference to the field.\nRename this <code>ChunkedArray</code>.\nApply a rolling custom function. This is pretty slow …\nApply a rolling custom function. This is pretty slow …\nSample a fraction between 0.0-1.0 of this <code>ChunkedArray</code>.\nSample n datapoints from this <code>ChunkedArray</code>.\nSet the null count directly.\nSet the ‘sorted’ bit meta info.\nShrink the capacity of this array to fit its length.\nSlice the array. The chunks are reallocated the underlying …\nGet the tail of the <code>ChunkedArray</code>\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nTraits and utilities for temporal data.\nConvert an <code>StringChunked</code> to a <code>Series</code> of <code>DataType::Decimal</code>. …\nSet the logical type of the <code>ListChunked</code>.\nIf all nested <code>Series</code> have the same length, a 2 dimensional …\nIf data is aligned in a single chunk and has no Null …\nSafety\nConvert to a <code>Vec</code> of <code>Option&lt;T::Native&gt;</code>.\nConvert to a <code>Vec</code> but don’t return <code>Option&lt;T::Native&gt;</code> if …\nApplies a function only to the non-null elements, …\nSeries to <code>ChunkedArray&lt;T&gt;</code>\nGet a single value from this <code>ChunkedArray</code>. Null values are …\nSafety\nReturn this <code>ChunkedArray</code> with a new name.\nSet the ‘sorted’ bit meta info.\nZip with a <code>ChunkedArray</code> then apply a binary function <code>F</code> …\nAppends a null slot into the builder\nAppends a null slot into the builder\nAppends a null slot into the builder\nAppends a null slot into the builder\nAppends a value of type <code>T</code> into the builder\nAppends a value of type <code>T</code> into the builder\nAppends a value of type <code>T</code> into the builder\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new ChunkedArray from an iterator.\nCreate a new ChunkedArray from an iterator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new StringChunkedBuilder\nAppends from an iterator over values\nAppends from an iterator over values\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOverflow is replaced with null\nAllows wrapping overflow\nRaises on overflow\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe no null iterator for a <code>BooleanArray</code>\nA <code>PolarsIterator</code> is an iterator over a <code>ChunkedArray</code> which …\nWrapper struct to convert an iterator of type <code>T</code> into one …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ncreate a new iterator\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nCreate a <code>Metadata</code> with only the properties set in <code>props</code>.\nCreate a <code>Metadata</code> with only the properties set in <code>props</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nMerge the maximum information from both <code>Metadata</code>s into one …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nValues need to implement this so that they can be stored …\nTrimmed down object safe polars object\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck validity\nCheck validity\nReturns an iterator of <code>Option&lt;&amp;T&gt;</code> over every element of …\nThis is a heap allocated utility that can be used to …\nSets the validity of this array.\nThis should be used as type information. Consider this a …\nGet a value at a certain index location\nGet a value at a certain index location\nGet a reference to the underlying data\nReturns this array with a new validity.\nAppends a null slot into the builder\nAppends a value of type <code>T</code> into the builder\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis trait can be registered, after which that global …\nTakes a <code>name</code> and <code>capacity</code> and constructs a new builder.\nAppend a <code>null</code> value.\nAppend a <code>T</code> of <code>ObjectChunked&lt;T&gt;</code> made generic via the <code>Any</code> …\nA function that creates an object builder\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTake the current state and materialize as a <code>Series</code> the …\nprevious value in array\nAggregation operations.\nFastest way to do elementwise operations on a …\nApply kernels on the arrow array chunks in a ChunkedArray.\nCast <code>ChunkedArray&lt;T&gt;</code> to <code>ChunkedArray&lt;N&gt;</code>\nCompare <code>Series</code> and <code>ChunkedArray</code>’s and get a <code>boolean</code> mask …\nCreate a new ChunkedArray filled with values at that index.\nExplode/flatten a List or String Series\nReplace None values with a value\nFilter values by a boolean mask.\nFill a ChunkedArray with one value.\nQuantile and median aggregation.\nReverse a <code>ChunkedArray&lt;T&gt;</code>\nThis differs from ChunkWindowCustom and ChunkWindow by not …\nCreate a <code>ChunkedArray</code> with new values by index or by …\nShift the values of a <code>ChunkedArray</code> by a number of periods.\nSort operations on <code>ChunkedArray</code>.\nGet unique values in a <code>ChunkedArray</code>\nVariance and standard deviation aggregation.\nCombine two <code>ChunkedArray</code> based on some predicate.\nnext value in array\nMask the first unique values as <code>true</code>\nMask the last unique values as <code>true</code>\nmaximum value in array\nreplace with the maximum value of that data type\nmean value of array\nminimal value in array\nreplace with the minimal value of that data type\nNo value.\nreplace with the value one\nSome value of type <code>T</code>.\nreplace with the value zero\nApply a closure elementwise including null values.\nApply kernel and return result as a new ChunkedArray.\nApply a kernel that outputs an array of different type.\nApply a closure elementwise and write results to a mutable …\nApply a closure elementwise. This is fastest when the null …\nRetrieve the indexes needed to sort this array.\nRetrieve the indexes need to sort this and the other …\nGet first index of the unique values in a <code>ChunkedArray</code>. …\nCast a <code>ChunkedArray</code> to <code>DataType</code>\nDoes not check if the cast is a valid one and may …\nCast a <code>ChunkedArray</code> to <code>DataType</code>\nCheck for equality.\nCheck for equality where <code>None == None</code>.\nReplace None values with a give value <code>T</code>.\nFilter values in the ChunkedArray with a boolean mask.\nReturns the argument unchanged.\nCreate a ChunkedArray with a single value.\nGet a single value. Beware this is slow.\nGet a single value. Beware this is slow. If you need to …\nGreater than comparison.\nGreater than or equal comparison.\nCalls <code>U::from(self)</code>.\nLess than comparison.\nLess than or equal comparison\nReturns the maximum value in the array, according to the …\nReturns the mean value in the array. Returns <code>None</code> if the …\nReturns the mean value in the array. Returns <code>None</code> if the …\nNumber of unique values in the <code>ChunkedArray</code>\nCreate a new ChunkedArray filled with values at that index.\nCheck for inequality.\nCheck for inequality where <code>None == None</code>.\nAggregate a given quantile of the ChunkedArray. Returns …\nReturn a reversed version of this array.\nSet the values at indexes <code>idx</code> to some optional value …\nSet the values at indexes <code>idx</code> by applying a closure to …\nSet the values where the mask evaluates to <code>true</code> to some …\nShift the values by a given period and fill the parts that …\nReturned a sorted <code>ChunkedArray</code>.\nCompute the standard deviation of this ChunkedArray/Series.\nAggregate the sum of the ChunkedArray. Returns <code>None</code> if not …\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nGet unique values of a ChunkedArray\nCompute the variance of this ChunkedArray/Series.\nCreate a new ChunkedArray with values from self where the …\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>ArrayRef</code> of the same type.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>ArrayRef</code> of the same type.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nApplies a kernel that produces <code>Array</code> types.\nSafety\nSafety\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSearch through a series of chunks for the first position …\nUtility trait to slice concrete arrow arrays whilst …\nSlices this <code>Array</code>.\nSlices the <code>Array</code>.\nReturn the indices of the bottom k elements.\nUtility trait to slice concrete arrow arrays whilst …\nSort options for multi-series sorting.\nOptions for single series sorting.\nIf true sort in descending order. Default <code>false</code>.\nOrder of the columns. Default all `false``.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf true maintain the order of equal elements. Default <code>false</code>…\nWhether maintain the order of equal elements. Default <code>false</code>…\nIf true sort in multiple threads. Default <code>true</code>.\nWhether sort in multiple threads. Default <code>true</code>.\nCreate <code>SortOptions</code> with default values.\nCreate <code>SortMultipleOptions</code> with default values.\nWhether place null values last. Default <code>false</code>.\nWhether place null values last. Default <code>false</code>.\nSlices this <code>Array</code>.\nSlices the <code>Array</code>.\nWhether maintain the order of equal elements. Default <code>false</code>…\nWhether to maintain the order of equal elements. Default …\nWhether sort in multiple threads. Default <code>true</code>.\nWhether to sort in multiple threads. Default <code>true</code>.\nWhether place null values last. Default <code>false</code>.\nWhether to place null values last. Default <code>false</code>.\nSpecify whether to place nulls last, per-column. Defaults …\nSpecify sorting order for the column. Default <code>false</code>.\nImplement order for all columns. Default <code>false</code>.\nSpecify order for each column. Defaults all <code>false</code>.\nReverse the order of sorting.\nReverse the order of sorting for each column.\nThe set of supported logical types in this crate.\nThe time units defined in Arrow.\nOpaque binary data of variable length whose offsets are …\nA binary type that inlines small values and can intern …\nA binary true or false.\n<code>true</code> and <code>false</code>.\nA 32-bit date representing the elapsed time since UNIX …\nAn <code>i32</code> representing the elapsed time since UNIX epoch …\nAn <code>i64</code> representing the elapsed time since UNIX epoch …\nA 64-bit date representing the elapsed time since UNIX …\nA 128-bit fixed point decimal number.\nFixed point decimal type optional precision and …\nDecimal value with precision and scale precision is the …\nDecimal backed by 256 bits\nA dictionary encoded array (<code>key_type</code>, <code>value_type</code>), where …\nMeasure of elapsed time. This elapsed time is a physical …\nExtension type.\nCharacterizes the name and the <code>DataType</code> of a column.\nOpaque binary data of fixed size. Enum parameter specifies …\nA list of some logical data type with a fixed number of …\nAn 16-bit float\nA 32-bit floating point number.\nA <code>f32</code>\nA 64-bit floating point number.\nA <code>f64</code>\nHashmap: maps the indexes from the global …\nA 16-bit integer number.\nAn <code>i16</code>\nA 32-bit integer number.\nAn <code>i32</code>\nA 64-bit integer number.\nAn <code>i64</code>\nAn 8-bit integer number.\nAn <code>i8</code>\nA “calendar” interval modeling elapsed time that takes …\nOpaque binary data of variable length whose offsets are …\nA list of some logical data type whose offsets are …\nA variable-length UTF-8 encoded string whose offsets are …\nNested type, contains arrays that are filled with one of …\nA nested list with a variable size in each row\nA list of some logical data type whose offsets are …\nUtf8Array: caches the string values and a hash of all …\nMaps a logical type to a chunked array implementation of …\nA nested type that is represented as\nTime in microseconds.\nTime in milliseconds.\nTime in nanoseconds.\nNull type\nCan be used to fmt and implements Any, so can be …\nA generic type that can be used in a <code>Series</code> &amp;’static str …\nThis hashmap uses an IdHasher\nSafety\nTime in seconds.\nA UTF8 encoded string type.\nString data\nAn UTF8 encoded string type.\nA nested <code>ArrowDataType</code> with a given number of <code>Field</code>s.\nA 64-bit time representing the elapsed time since midnight …\nA 32-bit time representing the elapsed time since midnight …\nA 64-bit time representing the elapsed time since midnight …\nA <code>i64</code> representing a timestamp measured in <code>TimeUnit</code> with …\nAn unsigned 16-bit integer number.\nAn <code>u16</code>\nAn unsigned 32-bit integer number.\nAn <code>u32</code>\nAn unsigned 64-bit integer number.\nAn <code>u64</code>\nAn unsigned 8-bit integer number.\nAn <code>u8</code>\nA nested datatype that can represent slots of differing …\nA type unknown to Arrow.\nA variable-length UTF-8 encoded string whose offsets are …\nA string type that inlines small values and can intern …\nReturns whether all values in the array are <code>true</code>.\nReturns whether all values in the column are <code>true</code>.\nThis is an iterator over a <code>ListChunked</code> that saves …\nSee <code>amortized_iter</code>.\nReturns whether any of the values in the column are <code>true</code>.\nReturns whether any of the values in the column are <code>true</code>.\nApply a closure <code>F</code> elementwise.\nApply a closure <code>F</code> elementwise.\nUtility that reuses an string buffer to amortize …\nIgnore the list indices and apply <code>func</code> to the inner type …\nApply a closure <code>F</code> elementwise.\nPanics\nPanics\nCast the leaf types of Lists/Arrays and keep the nesting.\nSets the <code>Field</code> datatype.\nReturns a reference to the <code>Field</code> datatype.\nGet data type of <code>ChunkedArray</code>.\nGet the matching <code>DataType</code> for this <code>AnyValue</code>`.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new ChunkedArray from an iterator.\nCreate a new ChunkedArray from an iterator.\nCreate a new ChunkedArray from an iterator.\nCreate a new ChunkedArray from an iterator.\nGets <code>AnyValue</code> from <code>LogicalType</code>\nGets <code>AnyValue</code> from <code>LogicalType</code>\nSafety\nSafety\nGet the inner values as <code>Series</code>, ignoring the list offsets.\nGet a hold to an object that can be formatted or …\nGet a hold to an object that can be formatted or …\nGet a reference to the <code>&amp;str</code> contained within <code>AnyValue</code>.\nSafety\nSafety\nGet the inner data type of the list.\nGet the inner data type of a nested type.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTry to coerce to an AnyValue with static lifetime. This …\nCheck if this <code>DataType</code> is an array.\nCheck if this <code>DataType</code> is a boolean.\nCheck if this <code>DataType</code> is a Decimal type (of any …\nCheck if this <code>DataType</code> is a basic floating point type …\nCheck if this <code>DataType</code> is an integer.\nCheck if the whole dtype is known.\nCheck if this <code>DataType</code> is a list.\nCheck if this <code>DataType</code> is a logical type\nCheck if this <code>DataType</code> is a basic numeric type (excludes …\nCheck if type is sortable\nCheck if datatype is a primitive type. By that we mean that\nCheck if this <code>DataType</code> is a struct\nCheck if this <code>DataType</code> is a temporal type\nReturns an iterator over the offsets of this chunked array.\nGet the absolute inner data type of a nested type.\nCreate a temporary <code>ChunkedArray</code> from a slice.\nReturns a reference to the <code>Field</code> name.\nCreates a new <code>Field</code>.\nOnly implemented for the same types and physical types!\nCreate <code>ChunkedArray</code> with samples from a Bernoulli …\nSets the <code>Field</code> name.\nCast <code>AnyValue</code> to the provided data type and return a new …\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nGather values from ChunkedArray by index.\nConvert to an Arrow data type.\nConverts the <code>Field</code> to an <code>arrow::datatypes::Field</code>.\nConvert to an Arrow Field\nConvert an <code>StringChunked</code> to a <code>Series</code> of <code>DataType::Decimal</code>. …\nSet the logical type of the <code>ListChunked</code>.\nReturns <code>&amp;self</code> for all but <code>ArrowDataType::Extension</code>. For …\nIf all nested <code>Series</code> have the same length, a 2 dimensional …\nConvert to the physical data type\nthe <code>PhysicalType</code> of this <code>ArrowDataType</code>.\nSafety\nCast <code>AnyValue</code> to the provided data type and return a new …\nSafety\nZip with a <code>ChunkedArray</code> then apply a binary function <code>F</code> …\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nTrue if all categories are represented in this array. When …\nRetrieve the indexes needed to sort this array.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>CategoricalChunked</code> from an array of <code>idx</code> and an …\nCreate a <code>CategoricalChunked</code> from a categorical indices. …\nCreate a <code>CategoricalChunked</code> from a fixed list of …\nGet a reference to the mapping of categorical types to the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>[Iterator]</code> that iterates over the <code>&amp;str</code> values of …\nGet a reference to the physical array (the categories).\nRegisters a value to a categorical index without pushing …\nReturned a sorted <code>ChunkedArray</code>.\nConvert a categorical column to its local representation.\nReturn whether or not the <code>CategoricalChunked</code> uses the …\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\n<code>str</code> to <code>Categorical</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>Categorical</code> to <code>str</code>\nGet the categories in this <code>RevMapping</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the length of the <code>RevMapping</code>\nCheck if the categoricals have a compatible mapping\nEnable the global string cache as long as the object is …\nDisable and clear the global string cache.\nEnable the global string cache.\nReturns the argument unchanged.\nHold the StringCache\nCalls <code>U::from(self)</code>.\nCheck whether the global string cache is enabled.\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nEnable the global string cache as long as the object is …\nDisable and clear the global string cache.\nEnable the global string cache.\nCheck whether the global string cache is enabled.\nContains the error value\nContains the success value\nConstant that help with creating error messages dependent …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the function that will be called by the <code>polars_warn!</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nKeep any of the unique rows This allows more optimizations\nA contiguous growable collection of <code>Series</code> that have the …\nKeep the first unique row.\nKeep the last unique row.\nKeep None of the unique rows.\nSame as <code>filter</code> but does not parallelize.\nEnsure all the chunks in the <code>DataFrame</code> are aligned.\nApply a closure to a column. This is the recommended way …\nApply a closure to a column at index <code>idx</code>. This is the …\nAggregate all the chunks in the DataFrame to a single …\nAggregate all the chunks in the DataFrame to a single …\nSelect a single column by name.\nSelected multiple columns by name.\nDrop a column by name. This is a pure method and will …\nRemove a column by name and return the column removed.\nDrop columns that are in <code>names</code>.\nDrop columns that are in <code>names</code> without allocating a <code>HashSet</code>…\nReturn a new <code>DataFrame</code> where all null values are dropped.\nGet the data types of the columns in the <code>DataFrame</code>.\nCreates an empty <code>DataFrame</code> usable in a compile time …\nCheck if <code>DataFrame</code>s are equal. Note that <code>None == None</code> …\nCheck if all values in <code>DataFrame</code>s are equal where …\nReturns an estimation of the total (heap) allocated size …\nExplode <code>DataFrame</code> to long format by exploding a column …\nExtend the memory backed by this <code>DataFrame</code> with the values …\nGet a reference to the schema fields of the <code>DataFrame</code>.\nReplace None values with one of the following strategies:\nTake the <code>DataFrame</code> rows by a boolean mask.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPanics\nCreate a new <code>DataFrame</code> from rows. This should only be used …\nCreate a new <code>DataFrame</code> from rows.\nCreate a new <code>DataFrame</code> from an iterator over rows.\nGet a row in the <code>DataFrame</code>. Beware this is slow.\nGet column index of a <code>Series</code> by name.\nExample\nGet the <code>Vec&lt;String&gt;</code> representing the column names.\nGet a reference to the <code>DataFrame</code> columns.\nGet mutable access to the underlying columns.\nGet a row from a <code>DataFrame</code>. Use of this is discouraged as …\nAmortize allocations by reusing a row. The caller is …\nAmortize allocations by reusing a row. The caller is …\nGet the supertype of the columns in this DataFrame\nGroup DataFrame using a Series column.\nGroup DataFrame using a Series column. The groups are …\nHash and combine the row values\nGet the head of the <code>DataFrame</code>.\nGet the height of the <code>DataFrame</code> which is the number of …\nAdd multiple <code>Series</code> to a <code>DataFrame</code>. The added <code>Series</code> are …\nAdd multiple <code>Series</code> to a <code>DataFrame</code>. The added <code>Series</code> are …\nAdd columns horizontally.\nInsert a new column at a given index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a mask of all the duplicated rows in the <code>DataFrame</code>.\nReturns <code>true</code> if the <code>DataFrame</code> contains no rows.\nGet a mask of all the unique rows in the <code>DataFrame</code>.\nIterator over the columns as <code>Series</code>.\nIterator over the rows in this <code>DataFrame</code> as Arrow …\nIterator over the rows in this <code>DataFrame</code> as Arrow …\nAggregate the column horizontally to their max values.\nCompute the mean of all values horizontally across columns.\nUnpivot a <code>DataFrame</code> from wide to long format.\nSimilar to melt, but without generics. This may be easier …\nAggregate the column horizontally to their min values.\nThe number of chunks per column\nCreate a DataFrame from a Vector of Series.\nCreate a new <code>DataFrame</code> but does not check the length or …\nCreate a new <code>DataFrame</code> but does not check the length of …\nCreate a new <code>DataFrame</code> that shows the null counts per …\nSplit into multiple DataFrames partitioned by groups\nSplit into multiple DataFrames partitioned by groups Order …\nPipe different functions/ closure operations that work on …\nPipe different functions/ closure operations that work on …\nPipe different functions/ closure operations that work on …\nRemoves the last <code>Series</code> from the <code>DataFrame</code> and returns it, …\nChecks if the Arc ptrs of the <code>Series</code> are equal\nRename a column in the <code>DataFrame</code>.\nReplace a column with a <code>Series</code>.\nReplace column at index <code>idx</code> with a <code>Series</code>.\nReplace or update a column. The difference between this …\nGet a <code>DataFrame</code> with all the columns in reversed order.\nSample a fraction between 0.0-1.0 of this <code>DataFrame</code>.\nSample n datapoints from this <code>DataFrame</code>.\nGet the <code>DataFrame</code> schema.\nCheck if <code>DataFrame</code>’ schemas are equal.\nSelect column(s) from this <code>DataFrame</code> and return a new …\nSelect a <code>Series</code> by index.\nSelect column(s) from this <code>DataFrame</code> by range and return a …\nSelect column(s) from this <code>DataFrame</code> and return them into …\nSelect with a known schema.\nSelect with a known schema. This doesn’t check for …\nSet the column names.\nGet (height, width) of the <code>DataFrame</code>.\nShift the values by a given period and fill the parts that …\nReturns true if the chunks of the columns do not align and …\nShrink the capacity of this DataFrame to fit its length.\nSlice the <code>DataFrame</code> along the rows.\nReturn a sorted clone of this <code>DataFrame</code>.\nSort <code>DataFrame</code> in place.\nSum all values horizontally across columns.\nGet the tail of the <code>DataFrame</code>.\nTake <code>DataFrame</code> rows by index values.\nSafety\nSafety\nCreate a 2D <code>ndarray::Array</code> from this <code>DataFrame</code>. This …\nTranspose a DataFrame. This is a very expensive operation.\nApply a closure that may fail to a column. This is the …\nApply a closure that may fail to a column at index <code>idx</code>. …\nCreate a new <code>DataFrame</code> from an iterator over rows. This …\nGet column index of a <code>Series</code> by name.\nUnstable distinct. See <code>DataFrame::unique_stable</code>.\nDrop duplicate rows from a <code>DataFrame</code>. <em>This fails when </em>…\nConcatenate a <code>DataFrame</code> to this <code>DataFrame</code> and return as …\nConcatenate a <code>DataFrame</code> to this <code>DataFrame</code>\nGet the width of the <code>DataFrame</code> which is the number of …\nAdd a new column to this <code>DataFrame</code> or replace an existing …\nAdd a new column to this <code>DataFrame</code> or replace an existing …\nAdds a column to the <code>DataFrame</code> without doing any checks on …\nAdd a new column at index 0 that counts the rows.\nAdd a row index column in place.\nArguments for <code>[DataFrame::melt]</code> function\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether the melt may be done in the streaming engine This …\nReturned by a group_by operation on a DataFrame. This …\nIndexes of the groups, the first index is stored …\nEvery group is indicated by an array where the\nUsed to create the tuples for a group_by operation.\nSlice is always sorted in ascending order.\nAggregate the groups of the group_by operation into lists.\nApply a closure over the groups as a new <code>DataFrame</code>.\nAggregate grouped series and compute the number of values …\nAggregate grouped <code>Series</code> and find the first value per …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the internal representation of the GroupBy operation. …\nGet the internal representation of the GroupBy operation. …\nCreate the tuples need for a group_by operation. * The …\nCreate the tuples need for a group_by operation. * The …\nGet the group_by group indexes.\nGet a mutable reference to the <code>GroupsIdx</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAggregate grouped <code>Series</code> and return the last value per …\nAggregate grouped series and compute the maximum value per …\nAggregate grouped series and compute the mean per group.\nAggregate grouped <code>Series</code> and determine the median per …\nAggregate grouped series and compute the minimal value per …\nAggregate grouped <code>Series</code> by counting the number of unique …\nApply a closure over the groups as a new <code>DataFrame</code> in …\nAggregate grouped <code>Series</code> and determine the quantile per …\nSelect the column(s) that should be aggregated. You can …\nAggregate grouped <code>Series</code> and determine the standard …\nAggregate grouped series and compute the sum per group.\nSafety\nGet a reference to the <code>GroupsIdx</code>.\nGet a reference to the <code>GroupsSlice</code>.\nAggregate grouped <code>Series</code> and determine the variance per …\nHelper that combines the groups into a parallel iterator …\nSame helper as <code>_agg_helper_idx</code> but for aggregations that …\nSafety\nAn <code>AnyValueBuffer</code> that should be used when we trust the …\nSafety\nWill add the <code>AnyValue</code> into <code>Self</code> and unpack as the physical …\nCoerces a slice of datatypes into a single supertype.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInfer schema from rows and set the first no null type as …\nInfer the schema of rows by determining the supertype of …\nInfer the schema data types of rows by determining the …\nConcat <code>DataFrame</code>s diagonally. Concat diagonally thereby …\nConcat <code>DataFrame</code>s horizontally. Concat horizontally and …\nContains an idx of a row in a DataFrame and the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPopulate a multiple key hashmap with row indexes. Instead …\nCompute the hash for all values in the array.\nCompute the hash for all values in the array.\nA thread-safe reference-counting pointer. ‘Arc’ stands …\nRepresents Arrow’s metadata of a “column”.\nAn ordered sequence of <code>Field</code>s with associated <code>Metadata</code>.\nAggregations that return <code>Series</code> of unit length. Those can …\nContains the error value\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nNo value.\nContains the success value\nUtility trait to slice concrete arrow arrays whilst …\nSome value of type <code>T</code>.\nEnable the global string cache as long as the object is …\nReturns a reference to the underlying allocator.\nProvides a raw pointer to the data.\nConverts to <code>Arc&lt;T&gt;</code>.\nConverts to <code>Arc&lt;[T]&gt;</code>.\nSet the labels at the center of the window.\nChecked integer division. Computes self / rhs, returning …\nMakes a clone of the <code>Arc</code> pointer.\nComparison for two <code>Arc</code>s.\nCast null arrays to inner type and ensure that all offsets …\nReturns the <code>Field</code>’s <code>ArrowDataType</code>.\nIts logical <code>ArrowDataType</code>\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCreates an empty <code>[T]</code> inside an Arc\nCreates an empty str inside an Arc\nCreates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.\nCreates an empty CStr inside an Arc\nAttempt to downcast the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a …\nDowncasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete …\nCreates a new <code>Weak</code> pointer to this allocation.\nDrops the <code>Arc</code>.\nEquality for two <code>Arc</code>s.\nThe fields composing this schema.\nReturns a new <code>ArrowSchema</code> with a subset of all fields …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>[T; N]</code> into an <code>Arc&lt;[T]&gt;</code>.\nCopies the string into a newly allocated Arc&lt;OsStr&gt;.\nConverts a <code>T</code> into an <code>Arc&lt;T&gt;</code>\nConverts a <code>PathBuf</code> into an Arc&lt;Path&gt; by moving the <code>PathBuf</code> …\nReturns the argument unchanged.\nAllocate a reference-counted slice and fill it by cloning <code>v</code>…\nAllocate a reference-counted <code>str</code> and copy <code>v</code> into it.\nAllocate a reference-counted slice and move <code>v</code>’s items …\nAllocate a reference-counted <code>str</code> and copy <code>v</code> into it.\nConverts an <code>OsString</code> into an Arc&lt;OsStr&gt; by moving the …\nConverts a <code>&amp;CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the contents …\nCreate an atomically reference-counted pointer from a …\nConverts an atomically reference-counted string slice into …\nConverts a <code>Path</code> into an <code>Arc</code> by copying the <code>Path</code> data into …\nConverts a <code>CString</code> into an Arc&lt;CStr&gt; by moving the <code>CString</code> …\nMove a boxed object to a new, reference-counted allocation.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSafety\nSafety\nTakes each element in the <code>Iterator</code> and collects it into an …\nCreate a list-array from an iterator. Used in group_by …\nSafety\nCreate a list-array from an iterator. Used in group_by …\nCreate a list-array from an iterator. Used in group_by …\nCreate a list-array from an iterator. Used in group_by …\nConstructs an <code>Arc&lt;T&gt;</code> from a raw pointer.\nConstructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.\nInitialize by name and values.\n‘Greater than or equal to’ comparison for two <code>Arc</code>s.\nReturns a mutable reference into the given <code>Arc</code>, if there …\nReturns a mutable reference into the given <code>Arc</code>, without …\nGreater-than comparison for two <code>Arc</code>s.\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nConsumes the <code>Arc</code>, returning the wrapped pointer.\nConsumes the <code>Arc</code>, returning the wrapped pointer and …\nIts nullability\n‘Less than or equal to’ comparison for two <code>Arc</code>s.\nLess-than comparison for two <code>Arc</code>s.\nMakes a mutable reference into the given <code>Arc</code>.\nGet the max of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nGet the max of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nGet the median of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nAdditional custom (opaque) metadata.\nOptional metadata.\nAmount of elements in the window that should be filled …\nGet the min of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nGet the min of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nIts name\nInequality for two <code>Arc</code>s.\nTranslate the negative index to an offset.\nInitialize by name and values.\nConstructs a new <code>Arc&lt;T&gt;</code>.\nCreates a new <code>Field</code>.\nConstructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the …\nConstructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.\nConstructs a new <code>Arc</code> with uninitialized contents.\nConstructs a new <code>Arc</code> with uninitialized contents in the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nPartial comparison for two <code>Arc</code>s.\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>…\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. …\nGet the product of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nGet the product of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nReturns <code>true</code> if the two <code>Arc</code>s point to the same allocation …\nGet the quantile of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nSlices this <code>Array</code>.\nSlices the <code>Array</code>.\nGet the standard deviation of the <code>ChunkedArray</code> as a new …\nGets the number of strong (<code>Arc</code>) pointers to this …\nGet the sum of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nGet the sum of the <code>ChunkedArray</code> as a new <code>Series</code> of length …\nConstructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation …\nConstructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, …\nConstructs a new <code>Arc</code> with uninitialized contents, …\nConstructs a new <code>Arc</code> with uninitialized contents, in the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if …\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, …\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nIf we have the only reference to <code>T</code> then unwrap it. …\nGet the variance of the <code>ChunkedArray</code> as a new <code>Series</code> of …\nGets the number of <code>Weak</code> pointers to this allocation.\nAn optional slice with the same length as the window that …\nThe length of the window.\nCreates a new <code>Field</code> with metadata.\nAttaches a <code>Metadata</code> to <code>ArrowSchema</code>\nSafety\nSafety\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHashmap: maps the indexes from the global …\nUtf8Array: caches the string values and a hash of all …\nUtility trait to slice concrete arrow arrays whilst …\nSlices this <code>Array</code>.\nSlices the <code>Array</code>.\nEnable the global string cache as long as the object is …\nDisable and clear the global string cache.\nEnable the global string cache.\nCheck whether the global string cache is enabled.\nThis trait exists to be unify the API of polars Schema and …\nA map from field/column name (<code>String</code>) to the type of that …\nWhether the schema contains a field named <code>name</code>\nReturns the argument unchanged.\nGet a reference to the dtype of the field named <code>name</code>, or …\nGet references to the name and dtype of the field at <code>index</code>\nGet mutable references to the name and dtype of the field …\nLook up the name in the schema and return an owned <code>Field</code> …\nReturn all data about the field named <code>name</code>: its index in …\nGet a vector of all column names.\nGet the index of a column by name.\nInsert a field with <code>name</code> and <code>dtype</code> at the given <code>index</code> into …\nCalls <code>U::from(self)</code>.\nIterates over the <code>(&amp;name, &amp;dtype)</code> pairs in this schema\nIterates over references to the dtypes in this schema\nIterates over mut references to the dtypes in this schema\nIterates the <code>Field</code>s in this schema, constructing them anew …\nIterates over references to the names in this schema\nThe number of fields in the schema\nMerge <code>other</code> into <code>self</code>\nMerge borrowed <code>other</code> into <code>self</code>\nCreate a new, empty schema\nCreate a new schema from this one, inserting a field with …\nSwap-remove a field by name and, if the field existed, …\nRename field <code>old</code> to <code>new</code>, and return the (owned) old name\nReserve <code>additional</code> memory spaces in the schema.\nChange the field named <code>name</code> to the given <code>dtype</code> and return …\nChange the field at the given index to the given <code>dtype</code> and …\nRemove a field by name, preserving order, and, if the …\nRemove a field by name, preserving order, and, if the …\nConvert self to <code>ArrowSchema</code> by cloning the fields\nTake another <code>Schema</code> and try to find the supertypes between …\nGet a reference to the dtype of the field named <code>name</code>, or …\nLook up the name in the schema and return an owned <code>Field</code> …\nReturn all data about the field named <code>name</code>: its index in …\nGet a mutable reference to the dtype of the field named …\nCreate a new, empty schema with capacity\nInsert a new column in the <code>Schema</code>\nUsed to convert a <code>ChunkedArray</code>, <code>&amp;dyn SeriesTrait</code> and <code>Series</code>\nSeries\nSafety\nCreate a new Series without checking if the inner dtype of …\nAppend in place. This is done by adding the chunks of <code>other</code>…\nRetrieve the indexes needed for a sort.\nRetrieve the indexes needed for a sort.\nGet first indexes of unique values.\nGet first indexes of unique values.\nReturns a reference to the Arrow ArrayRef\nGet a hold to self as <code>Any</code> trait reference.\nGet a hold to self as <code>Any</code> trait reference. Only …\nGet a hold to self as <code>Any</code> trait reference. Only …\nPacks every element into a list.\nRechunk and return a pointer to the start of the Series. …\nRechunk and return a pointer to the start of the Series. …\nOnly implemented for numeric types\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Binary]</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Binary]</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Boolean]</code>\nCast from physical to logical types without any checks on …\nCast <code>[Series]</code> to another <code>[DataType]</code>.\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Categorical]</code>\nGet the lengths of the underlying chunks\nUnderlying chunks.\nUnderlying chunks.\nSafety\nClone inner ChunkedArray and wrap in a new Arc\nRedo a length and null_count compute\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Decimal]</code>\nDrop all null values and return a new Series.\nDrop all null values and return a new Series.\nGet datatype of series.\nGet datatype of series.\nCreate a boolean mask by checking for equality.\nCreate a boolean mask by checking for equality.\nCheck if series are equal. Note that <code>None == None</code> …\nCheck if all values in series are equal where <code>None == None</code> …\nReturns an estimation of the total (heap) allocated size …\nExplode a list Series. This expands every item to a new …\nExtend the memory backed by this array with the values …\nExtend with a constant value.\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Float32]</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Float64]</code>\nGet field (used in schema)\nGet field (used in schema)\nReplace None values with one of the following strategies:\nFilter by boolean mask. This operation clones data.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a new <code>Series</code> from a slice of AnyValues.\nConstruct a new <code>Series</code> with the given <code>dtype</code> from a slice …\nTakes chunks and a polars datatype and constructs the …\nTraverse and collect every nth element in a new array.\nGet a single value by index. Don’t use this operation …\nGet a pointer to the underlying data of this <code>Series</code>. Can …\nRecurse nested types until we are at the leaf array.\nGet the value at this index as a downcastable Any trait …\nGet the value at this index as a downcastable Any trait …\nGet the value at this index as a downcastable Any trait …\nGet the value at this index as a downcastable Any trait …\nGet a single value by index. Don’t use this operation …\nGet a single value by index. Don’t use this operation …\nCreate a boolean mask by checking if self &gt; rhs.\nCreate a boolean mask by checking if self &gt;= rhs.\nReturn if any the chunks in this <code>[ChunkedArray]</code> have a …\nGet the head of the Series.\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Int16]</code>\nUnpack to <code>ChunkedArray</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Int64]</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Int8]</code>\nConvert the values of this Series to a ListChunked with a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if Series is empty.\nCheck if Series is empty.\nCheck if numeric value is finite\nCheck if float value is infinite\nCheck if float value is NaN (note this is different than …\nCheck if float value is NaN (note this is different than …\nGet a mask of the non-null values.\nGet a mask of the null values.\niterate over <code>Series</code> as <code>AnyValue</code>.\nGet length of series.\nTake <code>num_elements</code> from the top as a zero copy view.\nTake <code>num_elements</code> from the top as a zero copy view.\nUnpack to <code>ChunkedArray</code> of dtype list\nCreate a boolean mask by checking if self &lt; rhs.\nCreate a boolean mask by checking if self &lt;= rhs.\nReturns the maximum value in the array, according to the …\nGet the max of the Series as a new Series of length 1.\nGet the max of the Series as a new Series of length 1.\nReturns the mean value in the array Returns an option …\nReturns the mean value in the array Returns an option …\nReturns the median value in the array Returns an option …\nReturns the median value in the array Returns an option …\nGet the median of the Series as a new Series of length 1.\nGet the median of the Series as a new Series of length 1.\nReturns the minimum value in the array, according to the …\nGet the min of the Series as a new Series of length 1.\nGet the min of the Series as a new Series of length 1.\nNumber of chunks in this Series\nNumber of chunks in this Series\nGet unique values in the Series.\nGet unique values in the Series.\nName of series.\nConstruct a new <code>Series</code> from a collection of <code>AnyValue</code>.\nCreate a new empty Series.\nCreate a new Series filled with values from the given …\nCreate a boolean mask by checking for inequality.\nCreate a boolean mask by checking for inequality.\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::Null]</code>\nCount the null values.\nGet the product of an array.\nGet the quantile of the ChunkedArray as a new Series of …\nGet the quantile of the ChunkedArray as a new Series of …\nAggregate all chunks to a contiguous array of memory.\nRename the Series.\nRename series.\nreturn a Series in reversed order\nApply a custom function over a rolling/ moving window of …\nApply a custom function over a rolling/ moving window of …\nSample a fraction between 0.0-1.0 of this <code>ChunkedArray</code>.\nShift the values by a given period and fill the parts that …\nShrink the capacity of this array to fit its length.\nShrink the capacity of this array to fit its length.\nShrink the capacity of this array to fit its length.\nGet a zero copy view of the data.\nSort the series with specific options.\nReturns the std value in the array Returns an option …\nReturns the std value in the array Returns an option …\nGet the standard deviation of the Series as a new Series …\nGet the standard deviation of the Series as a new Series …\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::String]</code>\nCast throws an error if conversion had overflows\nCompute the sum of all values in this Series. Returns …\nGet the sum of the Series as a new Scalar.\nGet the sum of the Series as a new Scalar.\nGet the sum of the Series as a new Series of length 1. …\nGet the tail of the Series.\nTake by index. This operation is clone.\nTake by index. This operation is clone.\nTake by index.\nTake by index.\nTake by index if ChunkedArray contains a single chunk.\nConvert a chunk in the Series to the correct Arrow type. …\nCast numerical types to f64, and keep floats as is.\nCast a datelike Series to their physical representation. …\nTry to set the <code>Metadata</code> for the underlying <code>ChunkedArray</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::UInt16]</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::UInt32]</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::UInt64]</code>\nUnpack to <code>ChunkedArray</code> of dtype <code>[DataType::UInt8]</code>\nGet unique values in the Series.\nGet unique values in the Series.\nCompute the unique elements, but maintain order. This …\nReturns the var value in the array Returns an option …\nReturns the var value in the array Returns an option …\nGet the variance of the Series as a new Series of length 1.\nGet the variance of the Series as a new Series of length 1.\nReturn this Series with a new name.\nCreate a new ChunkedArray with values from self where the …\nA <code>[Series]</code> that amortizes a few allocations during …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSwaps inner state with the <code>array</code>. Prefer …\nTemporary swaps out the array, and restores the original …\nChecked integer division. Computes self / rhs, returning …\nChecked integer division. Computes self / rhs, returning …\nChecked integer division. Computes self / rhs, returning …\ndrop nulls\nignore nulls\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nJust a wrapper structure. Useful for certain impl …\nThis takes ownership of the DataFrame so that drop is …\nThis takes ownership of the DataFrame so that drop is …\nEnsure the chunks in both ChunkedArrays have the same …\nPanics\nDetermine the supertype of a collection of <code>AnyValue</code>.\nDetermine the supertype and the number of unique data …\nensure that nulls are propagated to both arrays\nConcat the DataFrames to a single DataFrame.\nConcat the DataFrames to a single DataFrame.\nConvert a collection of <code>DataType</code> into a schema.\nGiven multiple data types, determine the data type that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven two data types, determine the data type that both …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSplits, but doesn’t flatten chunks. E.g. a container can …\nSplit a <code>Container</code> in <code>target</code> elements. The target doesn’t …\nSplit a <code>DataFrame</code> in <code>target</code> elements. The target doesn’t …\nTurn any iterator in a trusted length iterator\nGiven two data types, determine the data type that both …\nA utility that allocates an <code>AmortSeries</code>. The applied …")